module Codegen.Model where

import Prelude

import Codegen.AST (Declaration, Ident, RowLabel, Type)
import Codegen.AST.Sugar.Type (app, array, constructor) as Type
import Codegen.AST.Types (Fields) as AST.Types
import Codegen.TS.Types (InstanceProps, InstantiationStrategy)
import Data.Either (Either)
import Data.Foldable (intercalate)
import Data.Generic.Rep (class Generic)
import Data.Generic.Rep.Show (genericShow)
import Data.Maybe (Maybe)
import Data.Moldy (class Moldable, Moldy(..), moldMap, moldlDefault, moldrDefault)
import ReadDTS.Instantiation (Type) as ReadDTS.Instantiation

-- | Drives generation of props by providing info about:
-- |
-- | * `base` - row of props provided by the user
-- |          (possibly to complicated for a codegen)
-- |
-- | * `generate` - props which should be autogenerated
-- |
-- | * `instantiation` - a hook into codegen type specizliation step
-- |

type PropsType =
  { base :: AST.Types.Fields Type
  , generate :: Array RowLabel
  -- | An escape hatch for tweaking low level props extraction
  , instantiation :: Maybe
      { extractProps :: ReadDTS.Instantiation.Type -> Either (Array String) InstanceProps
      , strategy :: InstantiationStrategy
      }
  }

type Component
  = { extraDeclarations :: Array Declaration
    , inherits :: Maybe Type
    -- | `ModulePath` value relative to `@material-ui/core/`
    , modulePath :: ModulePath
    , propsType :: PropsType
    , tsc ::
      { strictNullChecks :: Boolean }
    }

type ComponentName
  = String

componentName :: Component -> ComponentName
componentName = pathName <<< _.modulePath

componentFullPath :: Component -> ModulePath
componentFullPath { modulePath } = Path "MUI" (Path "Core" modulePath)

type IconName
  = String

-- | We should probably have here `ModulePath` for consistency
-- | but icons are located directly under `@material-ui/icons/`
-- | so we can use string to simplify some processing and FFI.
newtype Icon
  = Icon IconName

derive instance eqIcon :: Eq Icon

iconName :: Icon -> IconName
iconName (Icon s) = s

-- | Module path relative to `@material-ui/icons`
iconPath :: Icon -> ModulePath
iconPath (Icon s) = Name s

iconFullPath :: Icon -> ModulePath
iconFullPath icon = Path "MUI" (Path "Icons" (iconPath icon))

-- | This ADT is used to describe the name of the Purescript module. It's also used to determine file names and generate FFI.
-- | Because it's used for FFI generation, it should mimic the structure of `@material-ui`. For example, when writing the
-- | `Typography` component, it's JS import is `@material-ui/core/Typography` so the correct value for module is
-- | `Path "MUI" (Path "Core" (Name "Typography"))`. Node that `MUI` will be removed in the FFI, so you get FFI that looks like
-- | `exports._Typography = require("@material-ui/core/Typography").default;`. That said, the module name in the generated
-- | PureScript will be `MUI.Core.Typography`
data ModulePath
  = Path String ModulePath
  | Name String

derive instance eqModulePath :: Eq ModulePath

derive instance ordModulePath :: Ord ModulePath

derive instance genericModulePath :: Generic ModulePath _

instance showModulePath :: Show ModulePath where
  show m = genericShow m

instance moldableModulePath :: Moldable ModulePath String where
  moldMap f (Path p m) = f p <> moldMap f m
  moldMap f (Name n) = f n
  moldl f z m = moldlDefault f z m
  moldr f z m = moldrDefault f z m

pathName :: ModulePath -> String
pathName (Name n) = n
pathName (Path _ p) = pathName p

psImportPath :: ModulePath -> String
psImportPath modulePath = intercalate "." (Moldy identity modulePath)

jsImportPath :: ModulePath -> String
jsImportPath modulePath = intercalate "/" (Moldy identity modulePath)

jsx :: Type
jsx = Type.constructor "React.Basic.JSX"

arrayJSX :: Type
arrayJSX = Type.array $ jsx

reactComponentApply :: Type -> Type
reactComponentApply t = Type.app (Type.constructor "React.Basic.ReactComponent") [ t ]

divProps :: Type
divProps = Type.constructor "React.Basic.DOM.Props_div"

nativeElementProps :: Type
nativeElementProps = Type.constructor "MUI.Core.NativeElementProps"

-- effectFn2 :: PropType -> PropType
-- effectFn2 = PropList (ImportProp "Effect.Uncurried" "EffectFn2")
--
-- syntheticEvent :: PropType
-- syntheticEvent = ImportProp "React.Basic.Events" "SyntheticEvent"
eventHandler :: Type
eventHandler = Type.constructor "React.Basic.Events.EventHandler"
